#!/usr/bin/env node

/**
 * Security Penetration Testing Script
 * Automated security testing for the PDF-to-Text SaaS platform
 * 
 * IMPORTANT: This script is for authorized testing only.
 * Only run against systems you own or have explicit permission to test.
 */

import https from 'https';
import http from 'http';
import fs from 'fs';
import crypto from 'crypto';

class SecurityPenTester {
  constructor(baseUrl = 'http://localhost:3000') {
    this.baseUrl = baseUrl;
    this.results = {
      timestamp: new Date().toISOString(),
      baseUrl,
      tests: [],
      summary: {
        total: 0,
        passed: 0,
        failed: 0,
        warnings: 0
      }
    };
  }

  async runAllTests() {
    console.log('üîí Starting Security Penetration Testing');
    console.log(`Target: ${this.baseUrl}`);
    console.log('=' .repeat(50));

    try {
      // Test categories
      await this.testSecurityHeaders();
      await this.testAuthentication();
      await this.testInputValidation();
      await this.testRateLimiting();
      await this.testFileUpload();
      await this.testCSRF();
      await this.testSessionManagement();
      await this.testInformationDisclosure();
      await this.testDDoSResilience();
      await this.testSQLInjection();
      await this.testXSS();

      this.generateReport();
    } catch (error) {
      console.error('‚ùå Testing failed:', error.message);
    }
  }

  async testSecurityHeaders() {
    console.log('\nüìã Testing Security Headers...');
    
    const requiredHeaders = [
      'strict-transport-security',
      'content-security-policy',
      'x-frame-options',
      'x-content-type-options',
      'x-xss-protection',
      'referrer-policy'
    ];

    try {
      const response = await this.makeRequest('GET', '/');
      const headers = response.headers;

      for (const header of requiredHeaders) {
        if (headers[header]) {
          this.addTestResult('security_headers', `${header} present`, 'PASS', {
            header,
            value: headers[header]
          });
        } else {
          this.addTestResult('security_headers', `${header} missing`, 'FAIL', {
            header,
            recommendation: `Add ${header} header for security`
          });
        }
      }

      // Test CSP strength
      if (headers['content-security-policy']) {
        const csp = headers['content-security-policy'];
        if (csp.includes("'unsafe-inline'")) {
          this.addTestResult('security_headers', 'CSP allows unsafe-inline', 'WARNING', {
            recommendation: 'Remove unsafe-inline from CSP for better security'
          });
        }
        if (csp.includes("'unsafe-eval'")) {
          this.addTestResult('security_headers', 'CSP allows unsafe-eval', 'FAIL', {
            recommendation: 'Remove unsafe-eval from CSP'
          });
        }
      }

    } catch (error) {
      this.addTestResult('security_headers', 'Failed to test headers', 'FAIL', {
        error: error.message
      });
    }
  }

  async testAuthentication() {
    console.log('\nüîê Testing Authentication...');

    try {
      // Test unauthenticated access to protected endpoints
      const protectedEndpoints = [
        '/api/process-pdf',
        '/api/usage-stats',
        '/api/stripe/create-checkout-session',
        '/api/user/update-profile'
      ];

      for (const endpoint of protectedEndpoints) {
        try {
          const response = await this.makeRequest('POST', endpoint, {}, {});
          
          if (response.statusCode === 401 || response.statusCode === 403) {
            this.addTestResult('authentication', `${endpoint} properly protected`, 'PASS');
          } else {
            this.addTestResult('authentication', `${endpoint} accessible without auth`, 'FAIL', {
              statusCode: response.statusCode,
              endpoint
            });
          }
        } catch (error) {
          // Connection refused or similar is expected for protected endpoints
          this.addTestResult('authentication', `${endpoint} connection failed`, 'WARNING', {
            note: 'Endpoint may be down or properly protected'
          });
        }
      }

      // Test weak authentication
      await this.testWeakPasswords();
      await this.testBruteForce();

    } catch (error) {
      this.addTestResult('authentication', 'Authentication testing failed', 'FAIL', {
        error: error.message
      });
    }
  }

  async testWeakPasswords() {
    const weakPasswords = [
      '123456',
      'password',
      'admin',
      'test',
      '12345678',
      'qwerty'
    ];

    for (const password of weakPasswords) {
      try {
        const response = await this.makeRequest('POST', '/api/auth/register', {
          'Content-Type': 'application/json'
        }, {
          email: `test${Date.now()}@example.com`,
          password: password,
          confirmPassword: password
        });

        if (response.statusCode === 400) {
          this.addTestResult('authentication', `Weak password rejected: ${password}`, 'PASS');
        } else {
          this.addTestResult('authentication', `Weak password accepted: ${password}`, 'FAIL', {
            password: password.replace(/./g, '*')
          });
        }
      } catch (error) {
        // Expected for weak passwords
      }
    }
  }

  async testBruteForce() {
    console.log('  Testing brute force protection...');
    
    const attempts = 10;
    const email = `bruteforce${Date.now()}@example.com`;
    let failedAttempts = 0;

    for (let i = 0; i < attempts; i++) {
      try {
        const response = await this.makeRequest('POST', '/api/auth/login', {
          'Content-Type': 'application/json'
        }, {
          email,
          password: `wrong${i}`
        });

        if (response.statusCode === 429) {
          this.addTestResult('authentication', 'Brute force protection active', 'PASS', {
            attemptsBeforeBlock: i + 1
          });
          break;
        } else if (response.statusCode === 401) {
          failedAttempts++;
        }
      } catch (error) {
        // Expected
      }

      // Small delay between attempts
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    if (failedAttempts >= attempts) {
      this.addTestResult('authentication', 'No brute force protection detected', 'FAIL', {
        attemptsAllowed: attempts
      });
    }
  }

  async testInputValidation() {
    console.log('\nüõ°Ô∏è Testing Input Validation...');

    const maliciousInputs = [
      '<script>alert("xss")</script>',
      "'; DROP TABLE users; --",
      '../../../etc/passwd',
      '{{7*7}}',
      '${7*7}',
      '<%=7*7%>',
      '<img src=x onerror=alert(1)>',
      'javascript:alert(1)',
      '\x00\x01\x02\x03'
    ];

    for (const input of maliciousInputs) {
      try {
        const response = await this.makeRequest('POST', '/api/test-input', {
          'Content-Type': 'application/json'
        }, {
          testInput: input
        });

        // Check if malicious input is reflected back
        if (response.body && response.body.includes(input)) {
          this.addTestResult('input_validation', 'Malicious input reflected', 'FAIL', {
            input: input.substring(0, 50) + '...',
            type: 'potential_xss'
          });
        } else {
          this.addTestResult('input_validation', 'Input properly sanitized', 'PASS');
        }
      } catch (error) {
        // Expected for malicious inputs
      }
    }
  }

  async testRateLimiting() {
    console.log('\n‚è±Ô∏è Testing Rate Limiting...');

    const endpoints = [
      { path: '/api/process-pdf', limit: 5 },
      { path: '/api/auth/login', limit: 5 },
      { path: '/api/usage-stats', limit: 60 }
    ];

    for (const endpoint of endpoints) {
      let blockedAt = null;
      
      for (let i = 0; i < endpoint.limit + 5; i++) {
        try {
          const response = await this.makeRequest('POST', endpoint.path);
          
          if (response.statusCode === 429) {
            blockedAt = i + 1;
            this.addTestResult('rate_limiting', `Rate limiting active on ${endpoint.path}`, 'PASS', {
              requestsBeforeBlock: blockedAt
            });
            break;
          }
        } catch (error) {
          // Expected
        }

        await new Promise(resolve => setTimeout(resolve, 50));
      }

      if (!blockedAt) {
        this.addTestResult('rate_limiting', `No rate limiting on ${endpoint.path}`, 'WARNING', {
          testedRequests: endpoint.limit + 5
        });
      }
    }
  }

  async testFileUpload() {
    console.log('\nüìÑ Testing File Upload Security...');

    const maliciousFiles = [
      {
        name: 'test.exe',
        content: 'MZ\x90\x00', // PE header
        type: 'application/x-executable'
      },
      {
        name: 'test.php',
        content: '<?php system($_GET["cmd"]); ?>',
        type: 'application/x-php'
      },
      {
        name: '../../../etc/passwd',
        content: 'root:x:0:0:root:/root:/bin/bash',
        type: 'text/plain'
      },
      {
        name: 'test.pdf.exe',
        content: '%PDF-1.4\nMZ\x90\x00',
        type: 'application/pdf'
      }
    ];

    for (const file of maliciousFiles) {
      try {
        const boundary = '----WebKitFormBoundary' + Math.random().toString(36);
        const formData = this.createFormData(boundary, file);

        const response = await this.makeRequest('POST', '/api/process-pdf', {
          'Content-Type': `multipart/form-data; boundary=${boundary}`,
          'Content-Length': formData.length
        }, formData);

        if (response.statusCode === 400 || response.statusCode === 415) {
          this.addTestResult('file_upload', `Malicious file rejected: ${file.name}`, 'PASS');
        } else {
          this.addTestResult('file_upload', `Malicious file accepted: ${file.name}`, 'FAIL', {
            fileName: file.name,
            statusCode: response.statusCode
          });
        }
      } catch (error) {
        // Expected for malicious files
      }
    }
  }

  async testCSRF() {
    console.log('\nüîÑ Testing CSRF Protection...');

    try {
      // Test if state-changing operations require CSRF tokens
      const stateChangingEndpoints = [
        '/api/stripe/create-checkout-session',
        '/api/user/update-profile',
        '/api/user/delete-account'
      ];

      for (const endpoint of stateChangingEndpoints) {
        const response = await this.makeRequest('POST', endpoint, {
          'Origin': 'https://evil.com',
          'Referer': 'https://evil.com/attack.html'
        }, {});

        if (response.statusCode === 403 || response.statusCode === 401) {
          this.addTestResult('csrf', `CSRF protection active on ${endpoint}`, 'PASS');
        } else {
          this.addTestResult('csrf', `Possible CSRF vulnerability on ${endpoint}`, 'FAIL', {
            endpoint,
            statusCode: response.statusCode
          });
        }
      }
    } catch (error) {
      this.addTestResult('csrf', 'CSRF testing failed', 'WARNING', {
        error: error.message
      });
    }
  }

  async testSessionManagement() {
    console.log('\nüç™ Testing Session Management...');

    try {
      // Test session fixation
      const response1 = await this.makeRequest('GET', '/');
      const cookies1 = response1.headers['set-cookie'] || [];

      const response2 = await this.makeRequest('POST', '/api/auth/login', {
        'Cookie': cookies1.join('; ')
      }, {
        email: 'test@example.com',
        password: 'testpassword'
      });

      const cookies2 = response2.headers['set-cookie'] || [];

      if (cookies2.length > 0 && cookies2.join('') !== cookies1.join('')) {
        this.addTestResult('session_management', 'Session regenerated after login', 'PASS');
      } else {
        this.addTestResult('session_management', 'Session not regenerated after login', 'WARNING', {
          recommendation: 'Regenerate session ID after authentication'
        });
      }

      // Test session timeout
      // This would require longer testing periods in practice
      this.addTestResult('session_management', 'Session timeout testing skipped', 'INFO', {
        note: 'Manual testing required for session timeout verification'
      });

    } catch (error) {
      this.addTestResult('session_management', 'Session management testing failed', 'WARNING', {
        error: error.message
      });
    }
  }

  async testInformationDisclosure() {
    console.log('\nüìä Testing Information Disclosure...');

    const sensitiveEndpoints = [
      '/api/debug',
      '/api/status',
      '/.env',
      '/package.json',
      '/config.json',
      '/api/admin',
      '/admin',
      '/debug'
    ];

    for (const endpoint of sensitiveEndpoints) {
      try {
        const response = await this.makeRequest('GET', endpoint);
        
        if (response.statusCode === 200) {
          this.addTestResult('information_disclosure', `Sensitive endpoint exposed: ${endpoint}`, 'FAIL', {
            endpoint,
            statusCode: response.statusCode
          });
        } else {
          this.addTestResult('information_disclosure', `Endpoint properly secured: ${endpoint}`, 'PASS');
        }
      } catch (error) {
        // Expected for non-existent endpoints
      }
    }

    // Test error message information leakage
    try {
      const response = await this.makeRequest('POST', '/api/nonexistent', {}, { invalid: 'data' });
      
      if (response.body && (
        response.body.includes('stack trace') ||
        response.body.includes('file path') ||
        response.body.includes('database error')
      )) {
        this.addTestResult('information_disclosure', 'Error messages leak sensitive information', 'FAIL');
      } else {
        this.addTestResult('information_disclosure', 'Error messages properly sanitized', 'PASS');
      }
    } catch (error) {
      // Expected
    }
  }

  async testDDoSResilience() {
    console.log('\nüåä Testing DDoS Resilience...');

    const concurrentRequests = 50;
    const promises = [];

    for (let i = 0; i < concurrentRequests; i++) {
      promises.push(this.makeRequest('GET', '/').catch(() => ({ statusCode: 0 })));
    }

    try {
      const responses = await Promise.all(promises);
      const blockedRequests = responses.filter(r => r.statusCode === 429).length;
      const successfulRequests = responses.filter(r => r.statusCode === 200).length;

      if (blockedRequests > 0) {
        this.addTestResult('ddos_resilience', 'DDoS protection active', 'PASS', {
          totalRequests: concurrentRequests,
          blocked: blockedRequests,
          successful: successfulRequests
        });
      } else if (successfulRequests < concurrentRequests / 2) {
        this.addTestResult('ddos_resilience', 'Server struggled with load', 'WARNING', {
          successfulRequests,
          totalRequests: concurrentRequests
        });
      } else {
        this.addTestResult('ddos_resilience', 'No obvious DDoS protection', 'WARNING', {
          recommendation: 'Consider implementing DDoS protection'
        });
      }
    } catch (error) {
      this.addTestResult('ddos_resilience', 'DDoS testing failed', 'WARNING', {
        error: error.message
      });
    }
  }

  async testSQLInjection() {
    console.log('\nüíâ Testing SQL Injection...');

    const sqlPayloads = [
      "'; DROP TABLE users; --",
      "' OR '1'='1",
      "' UNION SELECT * FROM users --",
      "'; INSERT INTO users VALUES('hacker','password'); --",
      "' OR 1=1 #"
    ];

    for (const payload of sqlPayloads) {
      try {
        const response = await this.makeRequest('POST', '/api/search-processing-content', {
          'Content-Type': 'application/json'
        }, {
          query: payload
        });

        // Check for SQL error messages or unexpected data
        if (response.body && (
          response.body.includes('SQL syntax') ||
          response.body.includes('mysql_') ||
          response.body.includes('ORA-') ||
          response.body.includes('Microsoft OLE DB')
        )) {
          this.addTestResult('sql_injection', 'SQL injection vulnerability detected', 'FAIL', {
            payload: payload.substring(0, 30) + '...'
          });
        } else {
          this.addTestResult('sql_injection', 'SQL injection attempt handled safely', 'PASS');
        }
      } catch (error) {
        // Expected for malicious inputs
      }
    }
  }

  async testXSS() {
    console.log('\nüï∏Ô∏è Testing Cross-Site Scripting (XSS)...');

    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert(1)>',
      'javascript:alert(1)',
      '<svg onload=alert(1)>',
      '"><script>alert(1)</script>',
      '\'-alert(1)-\'',
      '<iframe src="javascript:alert(1)"></iframe>'
    ];

    for (const payload of xssPayloads) {
      try {
        // Test reflected XSS
        const response = await this.makeRequest('GET', `/search?q=${encodeURIComponent(payload)}`);
        
        if (response.body && response.body.includes(payload)) {
          this.addTestResult('xss', 'Potential reflected XSS vulnerability', 'FAIL', {
            payload: payload.substring(0, 30) + '...'
          });
        } else {
          this.addTestResult('xss', 'XSS payload properly sanitized', 'PASS');
        }

        // Test stored XSS (would require user account and comment/profile functionality)
        // This is simplified for demo purposes
        
      } catch (error) {
        // Expected for malicious inputs
      }
    }
  }

  createFormData(boundary, file) {
    const formData = 
      `--${boundary}\r\n` +
      `Content-Disposition: form-data; name="file"; filename="${file.name}"\r\n` +
      `Content-Type: ${file.type}\r\n\r\n` +
      `${file.content}\r\n` +
      `--${boundary}--\r\n`;
    
    return Buffer.from(formData);
  }

  makeRequest(method, path, headers = {}, body = null) {
    return new Promise((resolve, reject) => {
      const url = new URL(path, this.baseUrl);
      const isHttps = url.protocol === 'https:';
      const lib = isHttps ? https : http;
      
      const options = {
        hostname: url.hostname,
        port: url.port || (isHttps ? 443 : 80),
        path: url.pathname + url.search,
        method: method,
        headers: {
          'User-Agent': 'SecurityPenTester/1.0',
          ...headers
        },
        timeout: 10000,
        rejectUnauthorized: false // For self-signed certificates in testing
      };

      if (body) {
        if (typeof body === 'object' && !Buffer.isBuffer(body)) {
          body = JSON.stringify(body);
          options.headers['Content-Type'] = 'application/json';
        }
        options.headers['Content-Length'] = Buffer.isBuffer(body) ? body.length : Buffer.byteLength(body);
      }

      const req = lib.request(options, (res) => {
        let responseBody = '';
        
        res.on('data', (chunk) => {
          responseBody += chunk;
        });
        
        res.on('end', () => {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            body: responseBody
          });
        });
      });

      req.on('error', reject);
      req.on('timeout', () => reject(new Error('Request timeout')));

      if (body) {
        req.write(body);
      }
      req.end();
    });
  }

  addTestResult(category, test, result, details = {}) {
    const testResult = {
      category,
      test,
      result,
      details,
      timestamp: new Date().toISOString()
    };

    this.results.tests.push(testResult);
    this.results.summary.total++;

    switch (result) {
      case 'PASS':
        this.results.summary.passed++;
        console.log(`  ‚úÖ ${test}`);
        break;
      case 'FAIL':
        this.results.summary.failed++;
        console.log(`  ‚ùå ${test}`);
        if (details.recommendation) {
          console.log(`     üí° ${details.recommendation}`);
        }
        break;
      case 'WARNING':
        this.results.summary.warnings++;
        console.log(`  ‚ö†Ô∏è ${test}`);
        break;
      case 'INFO':
        console.log(`  ‚ÑπÔ∏è ${test}`);
        break;
    }
  }

  generateReport() {
    console.log('\n' + '='.repeat(50));
    console.log('üîí SECURITY PENETRATION TEST REPORT');
    console.log('='.repeat(50));
    
    console.log(`\nüìä Summary:`);
    console.log(`   Total Tests: ${this.results.summary.total}`);
    console.log(`   Passed: ${this.results.summary.passed} ‚úÖ`);
    console.log(`   Failed: ${this.results.summary.failed} ‚ùå`);
    console.log(`   Warnings: ${this.results.summary.warnings} ‚ö†Ô∏è`);
    
    const passRate = ((this.results.summary.passed / this.results.summary.total) * 100).toFixed(1);
    console.log(`   Pass Rate: ${passRate}%`);

    // Group results by category
    const categories = {};
    this.results.tests.forEach(test => {
      if (!categories[test.category]) {
        categories[test.category] = [];
      }
      categories[test.category].push(test);
    });

    console.log('\nüìã Detailed Results by Category:');
    for (const [category, tests] of Object.entries(categories)) {
      console.log(`\nüîπ ${category.toUpperCase().replace(/_/g, ' ')}`);
      
      const categoryStats = {
        passed: tests.filter(t => t.result === 'PASS').length,
        failed: tests.filter(t => t.result === 'FAIL').length,
        warnings: tests.filter(t => t.result === 'WARNING').length
      };
      
      console.log(`   Passed: ${categoryStats.passed}, Failed: ${categoryStats.failed}, Warnings: ${categoryStats.warnings}`);
      
      // Show failed tests
      const failedTests = tests.filter(t => t.result === 'FAIL');
      if (failedTests.length > 0) {
        console.log('   Failed Tests:');
        failedTests.forEach(test => {
          console.log(`     ‚ùå ${test.test}`);
          if (test.details.recommendation) {
            console.log(`        üí° ${test.details.recommendation}`);
          }
        });
      }
    }

    // Risk assessment
    console.log('\nüéØ Risk Assessment:');
    const criticalIssues = this.results.tests.filter(t => 
      t.result === 'FAIL' && 
      (t.category.includes('authentication') || 
       t.category.includes('sql_injection') || 
       t.category.includes('xss'))
    ).length;

    if (criticalIssues > 0) {
      console.log(`   üö® CRITICAL: ${criticalIssues} critical security issues found`);
      console.log('      Immediate action required!');
    } else if (this.results.summary.failed > 0) {
      console.log(`   ‚ö†Ô∏è MODERATE: ${this.results.summary.failed} security issues found`);
      console.log('      Address these issues before production deployment');
    } else {
      console.log('   ‚úÖ LOW: No critical security issues detected');
      console.log('      System appears to have good security posture');
    }

    // Save detailed report
    const reportPath = `security-pentest-report-${Date.now()}.json`;
    fs.writeFileSync(reportPath, JSON.stringify(this.results, null, 2));
    console.log(`\nüìÑ Detailed report saved to: ${reportPath}`);

    console.log('\n‚ö†Ô∏è IMPORTANT DISCLAIMER:');
    console.log('This automated test provides a basic security assessment.');
    console.log('It does not replace professional penetration testing.');
    console.log('Consider hiring security professionals for comprehensive testing.');
  }
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const baseUrl = args[0] || 'http://localhost:3000';
  
  console.log('üîí PDF-to-Text SaaS Security Penetration Testing Tool');
  console.log('‚ö†Ô∏è AUTHORIZED TESTING ONLY - Do not run against systems you do not own');
  console.log('');
  
  const tester = new SecurityPenTester(baseUrl);
  tester.runAllTests().catch(console.error);
}

export default SecurityPenTester;